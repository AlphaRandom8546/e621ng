<%= render partial: "uploads/upload_partials/css" %>
<%= render partial: "uploads/upload_partials/tag_preview" %>
<%= render partial: "uploads/upload_partials/source" %>
<%= render partial: "uploads/upload_partials/related" %>
<%= render partial: "uploads/upload_partials/uploader" %>
<div id="post-add">
  <div style="margin-bottom: 1rem;" class="section">
    <h2>Before uploading, read
      the <%= link_to "how to upload guide", wiki_pages_path(id: "howto:upload") %>.</h2>
    <p>Make sure you're not posting something on
      the <%= link_to "Avoid Posting List", help_pages_path(id: 'avoid_posting') %><br>
      Review the <%= link_to "Uploading Guidelines", help_pages_path(id: "uploading_guidelines") %>
      <br>
      Unsure what to tag your post
      with? <%= link_to "Tagging Checklist", help_pages_path(id: "tagging_checklist") %></p>
  </div>
  <%# if current_user.is_member_or_lower? && (current_user.upload_limit <= 5 || current_user.post_upload_throttle <= 5) %>
<!--    <div id="post-uploads-remaining" class="section<%# if [current_user.upload_limit, current_user.post_upload_throttle].min <= 0 %> sect_red<%# end %>" style="width:640px;">-->
<!--      <p>-->
<!--        You currently have <span class="post-uploads-remaining-count"><%#= current_user.upload_limit %></span> upload<%#= current_user.upload_limit!=1?"s":"" %> remaining.-->

        <%# if current_user.pending_flagged_posts.count > 0 %>
<!--          This number will go up as some of your <%#= link_to "<span class='post-uploads-remaining-count'>#{current_user.pending_flagged_posts.count}</span> pending/flagged posts", action: "index",tags: "user:#{current_user.name} status:pending" %> are approved.-->
        <%# end %>
<!--      </p>-->
<!--      You have <span class="post-uploads-remaining-count"><%#= current_user.post_upload_throttle %></span> uploads remaining this hour.-->
<!--      See <%#= link_to "here", controller: "user", action: "upload_limit" %> for more details.-->
<!--    </div>-->
  <%# elsif current_user.post_upload_throttle <= 5 %>
<!--    <div id="post-uploads-remaining" class="section<%# if current_user.post_upload_throttle <= 0 %> sect_red<%# end %>" style="width:640px;">-->
<!--      You have <span class="post-uploads-remaining-count"><%#= current_user.post_upload_throttle %></span> uploads remaining this hour.-->
<!--      See <%#= link_to "here", controller: "user", action: "upload_limit" %> for more details.-->
<!--    </div>-->
  <%# end %>
  <post-creator :safe="<%= CurrentUser.safe_mode? %>"></post-creator>
</div>
<!--<script type="text/javascript">-->
<!--  var userUploadTags = <%#= current_user.uploaded_tags_with_types.to_json %>;-->
<!--  var userRecentTags = <%#= current_user.recent_tags_with_types.to_json %>;-->
<!--  var userArtistTags = <%#= @artists.to_json %>;-->
<!--</script>-->
<script>
  var userUploadTags = [];
  var userRecentTags = [];
  var userArtistTags = [];
</script>
<script src="/vendor/vue.js"></script>
<script type="text/javascript">
  const thumbURLs = [
    "/images/notfound-preview.png",
    "/images/download-preview.png",
    "/images/webm-preview.png",
    "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="
  ];
  const thumbs = {
    webm: "/images/webm-preview.png",
    flash: "/images/download-preview.png",
    notfound: "/images/notfound-preview.png",
    none: 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='
  };
  const artist_checks = [
    {name: 'Unknown Artist'},
    {name: 'Anonymous Artist'}];

  const sex_checks = [
    {name: 'Male'},
    {name: 'Female'},
    {name: 'Cuntboy'},
    {name: 'Dickgirl'},
    {name: 'Hermaphrodite', tag: 'herm'},
    {name: 'Male-Herm', tag: 'maleherm'},
    {name: 'Ambiguous', tag: 'ambiguous_gender'}];

  const pairing_checks = [
    {name: 'Male/Male'},
    {name: 'Male/Female'},
    {name: 'Female/Female'},
    {name: 'Intersex/Male'},
    {name: 'Intersex/Female'},
    {name: 'Intersex/Intersex'}
  ];

  const char_count_checks = [
    {name: 'Solo'},
    {name: 'Duo'},
    {name: 'Group'},
    {name: 'Zero Pictured'}];

  const body_type_checks = [
    {name: 'Anthro'},
    {name: 'Feral'},
    {name: 'Humanoid'},
    {name: 'Human'},
    {name: 'Taur'}];

  function updatePreviewDims(e) {
    var img = e.target;
    if (thumbURLs.filter(function (x) {
      return img.src.indexOf(x) !== -1;
    }).length !== 0)
      return;
    this.previewHeight = img.naturalHeight;
    this.previewWidth = img.naturalWidth;
    this.overDims = (img.naturalHeight > 15000 || img.naturalWidth > 15000);
    updateDimensionTag.call(this);
  }

  function previewError() {
    this.previewWidth = this.previewHeight = 0;
    this.overDims = false;
    if (this.uploadURL === '' && !this.$refs['post_file']) {
      this.previewURL = thumbs.none;
    } else {
      this.previewURL = thumbs.notfound;
    }
  }

  function updatePreviewFile() {
    var self = this;
    var reader = new FileReader();
    var file = this.$refs['post_file'].files[0];
    this.previewHeight = 0;
    this.previewWidth = 0;
    reader.onload = function (e) {
      var src = e.target.result;

      if (file.type.match('video/webm'))
        src = thumbs.webm;
      else if (file.type.match('application/x-shockwave-flash'))
        src = thumbs.flash;
      self.previewURL = src;
    };
    reader.readAsDataURL(file);

    this.disableURLUpload = true;
  }

  function updatePreviewURL() {
    var self = this;
    if (this.uploadURL.length === 0 || (this.$refs['post_file'] && this.$refs['post_file'].files.length > 0)) {
      this.disableFileUpload = false;
      this.oldDomain = '';
      return;
    }
    this.disableFileUpload = true;
    var domain = $j("<a>").prop("href", this.uploadURL).prop("hostname");

    if (domain && domain != this.oldDomain) {
      $j.getJSON("/upload_whitelist/is_whitelisted", {url: this.uploadURL}, function (data) {
        if (data.domain)
          self.whitelistWarning(data.is_whitelisted, data.domain);
      });
    }
    this.oldDomain = domain;

    var src = thumbs.none;
    if (this.uploadURL.match(/^(https?\:\/\/|www).*?\.(jpg|jpeg|gif|png)/))
      src = this.uploadURL;
    else if (this.uploadURL.match(/^(https?\:\/\/|www).*?\.(swf)$/))
      src = thumbs.flash;
    else if (this.uploadURL.match(/^(https?\:\/\/|www).*?\.(webm)$/))
      src = thumbs.webm;

    this.previewURL = src;
  }

  function updateDimensionTag() {
    var self = this;
    if (!(self.previewHeight || self.previewWidth))
      return;
    var otherTags = ['low_res', 'hi_res', 'superabsurd_res', 'absurd_res'];
    var ourTag = function (h, w) {
      if (!(h && w)) {
        return null;
      }
      if ((h <= 500) && (w <= 500))
        return 'low_res';
      if ((h >= 10000) || (w >= 10000))
        return 'superabsurb_res';
      if ((h >= 2400) || (w >= 3200))
        return 'absurd_res';
      if ((h >= 1200) || (w >= 1600))
        return 'hi_res';
      return null;
    }(self.previewHeight, self.previewWidth);
    var tagIdx = otherTags.indexOf(ourTag);
    if (tagIdx > 0)
      otherTags.splice(tagIdx, 1);
    if (ourTag)
      self.pushTag(ourTag, true);
    for(var i = 0; i < otherTags.length; i++) {
      self.pushTag(otherTags[i], false);
    }
  }

  function updatePreview() {
    if (this.$refs['post_file'] && this.$refs['post_file'].files[0])
      updatePreviewFile.call(this);
    else
      updatePreviewURL.call(this);
  }

  function directURLCheck(url) {
    var patterns = [{reason: 'Thumbnail URL', test: /[at]\.facdn\.net/gi},
      {reason: 'Sample URL', test: /pximg\.net\/img-master/gi},
      // {reason: 'Sample URL', test: /\d+\.media\.tumblr\.com/gi}, // Tumblr broke raws.
      {reason: 'Sample URL', test: /d3gz42uwgl1r1y\.cloudfront\.net\/.*\/\d+x\d+\./gi},
      {reason: 'Sample URL', test: /pbs\.twimg\.com\/media\/\w+\.(jpg|png)(:large)?$/gi},
      {reason: 'Sample URL', test: /pbs\.twimg\.com\/media\/\w+\?format=/gi},
      {reason: 'Sample URL', test: /derpicdn\.net\/.*\/large\./gi},
      {reason: 'Sample URL', test: /metapix\.net\/files\/(preview|screen)\//gi},
      {reason: 'Sample URL', test: /sofurryfiles\.com\/std\/preview/gi}];
    for (var i = 0; i < patterns.length; ++i) {
      var pattern = patterns[i];
      if (pattern.test.test(url))
        return pattern.reason;
    }
    return '';
  }

  function clearFileUpload() {
    if (!(this.$refs['post_file'] && this.$refs['post_file'].files[0]))
      return;
    this.$refs['post_file'].value = null;
    this.disableURLUpload = this.disableFileUpload = false;
    this.previewURL = thumbs.none;
    this.previewHeight = this.previewWidth = 0;
    this.updatePreview();
  }

  var source = Vue.extend({
    template: '#source-template',
    props: ['value', 'index', 'last'],
    data: function () {
      return {
        backendValue: this.value
      };
    },
    computed: {
      'realValue': {
        get: function () {
          return this.backendValue;
        },
        set: function (v) {
          this.backendValue = v;
          this.$emit('input', v);
        }
      }
    },
    methods: {
      add: function () {
        this.$emit('add');
      },
      remove: function () {
        this.$emit('delete');
      }
    },
    watch: {
      value: function (v) {
        this.backendValue = v;
      }
    }
  });
  var checkbox = Vue.extend({
    template: '#checkbox-template',
    props: ['check', 'checks'],
    computed: {
      value: {
        get: function () {
          if (this.checks[this.tagName] === undefined)
            return false;
          return this.checks[this.tagName];
        },
        set: function (v) {
          this.$emit('set', this.tagName, v);
        }
      },
      tagName: function () {
        return this.check.tag || this.check.name.toLowerCase().replace(/ /g, '_');
      }
    }
  });
  var tagSorter = function (a, b) {
    return a[0] > b[0] ? 1 : -1;
  };
  var relatedTags = Vue.extend({
    template: '#related-tags',
    props: ['tags', 'related', 'loading'],
    data: function () {
      return {
        uploaded: (userUploadTags || []),
        recent: (userRecentTags || []).sort(tagSorter),
        artists: (userArtistTags || []).sort(tagSorter)
      };
    },
    methods: {
      toggle: function (tag) {
        this.$emit('tag-active', tag[0], !this.tagActive(tag));
      },
      tagLink: function (tag) {
        return '/post/index?tags=' + encodeURIComponent(tag[0]);
      },
      tagActive: function (tag) {
        return this.tags.indexOf(tag[0]) !== -1;
      },
      tagClasses: function (tag) {
        var classes = {'tag-active': this.tagActive(tag)};
        classes['tag-type-' + tag[2]] = true;
        return classes;
      },
      splitTags: function (tags) {
        var chunkArray = function (arr, size) {
          var chunks = [];
          for (var i = 0; i < arr.length; i += size) {
            chunks.push(arr.slice(i, i + size));
          }
          return chunks;
        };
        return chunkArray(tags, 15);
      }
    },
    computed: {
      tagGroups: {
        get: function () {
          var groups = [];
          if (this.uploaded && this.uploaded.length) {
            groups.push({
              title: "Quick Tags",
              tags: this.uploaded
            });
          }
          if (this.recent && this.recent.length) {
            groups.push({
              title: "Recent",
              tags: this.recent
            });
          }
          if (this.artists && this.artists.length) {
            groups.push({
              title: "Artists",
              tags: this.artists
            });
          }
          if (this.related && this.related.length) {
            for (var i = 0; i < this.related.length; i++) {
              groups.push(this.related[i]);
            }
          }
          if (this.loading) {
            groups.push({title: 'Loading Related Tags', tags: [['', '', '']]});
          }
          return groups;
        }
      }
    }
  });
  var tagPreviewTag = Vue.extend({
    functional: true,
    props: ['tag'],
    render: function (h, ctx) {
      var tag = ctx.props.tag;
      switch (tag.type) {
        default:
        case 'tag':
          return h('a', {
            staticClass: 'tag-preview tag-type-' + tag.tagType
          }, tag.a);
        case 'alias':
          return h('span', {staticClass: 'tag-preview tag-preview-alias'}, [
            h('del', undefined, [
              h('a', {staticClass: 'tag-type-' + tag.tagType}, tag.a)
            ]), ' → ', h('a', {staticClass: 'tag-type-' + tag.tagType}, tag.b)
          ]);
        case 'implication':
          return h('span', {staticClass: 'tag-preview tag-preview-implication'}, [
            h('a', {staticClass: 'tag-type-' + tag.tagType}, tag.a), ' ⇐ ', h('a', {staticClass: 'tag-type-' + tag.tagType}, tag.b)
          ]);
      }
    }
  });
  var tagPreview = Vue.extend({
    template: '#tag-preview',
    props: ['tags', 'loading'],
    components: {
      'tag-preview': tagPreviewTag
    },
    methods: {
      close: function () {
        this.$emit('close');
      }
    },
    computed: {
      splitTags: function () {
        var newTags = this.tags.concat([]);
        newTags.sort(function (a, b) {
          return a.a === b.a ? 0 : (a.a < b.a ? -1 : 1);
        });
        var chunkArray = function (arr, size) {
          var chunks = [];
          for (var i = 0; i < arr.length; i += size) {
            chunks.push(arr.slice(i, i + size));
          }
          return chunks;
        };
        return chunkArray(newTags, 15);
      }
    }
  });
  var editor = Vue.extend({
    template: '#post-creator',
    props: ['safe'],
    components: {
      'image-source': source,
      'image-checkbox': checkbox,
      'related-tags': relatedTags,
      'tag-preview': tagPreview
    },
    data: function () {
      var allChecks = {};
      var addChecks = function (check) {
        if (typeof check['tag'] !== "undefined") {
          allChecks[check.tag] = true;
          return
        }
        allChecks[check.name.toLowerCase().replace(' ', '_')] = true;
      };
      artist_checks.forEach(addChecks);
      sex_checks.forEach(addChecks);
      pairing_checks.forEach(addChecks);
      char_count_checks.forEach(addChecks);
      body_type_checks.forEach(addChecks);
      return {
        showErrors: false,
        whitelist: {
          visible: false,
          allowed: false,
          domain: ''
        },
        submitting: false,
        disableFileUpload: false,
        disableURLUpload: false,

        previewHeight: 0,
        previewWidth: 0,
        overDims: false,
        uploadURL: '',
        previewURL: thumbs.none,

        oldDomain: '',

        noSource: false,
        sources: [''],
        normalMode: true,

        checkboxes: {
          artist: artist_checks,
          sex: sex_checks,
          pairing: pairing_checks,
          count: char_count_checks,
          body: body_type_checks,
          selected: {},
          all: allChecks
        },
        tagEntries: {
          character: '',
          sex: '',
          bodyType: '',
          theme: '',
          other: ''
        },

        preview: {
          loading: false,
          show: false,
          tags: []
        },

        relatedTags: [],
        loadingRelated: false,

        parentID: '',
        description: '',
        rating: ''
      };
    },
    methods: {
      updatePreview: updatePreview,
      updatePreviewDims: updatePreviewDims,
      previewError: previewError,
      clearFile: clearFileUpload,
      whitelistWarning: function (allowed, domain) {
        this.whitelist.allowed = allowed;
        this.whitelist.domain = domain;
        this.whitelist.visible = true;
      },
      removeSource: function (i) {
        this.sources.splice(i, 1);
      },
      addSource: function () {
        if (this.sources.length < 5)
          this.sources.push('');
      },
      setCheck: function (tag, value) {
        Vue.set(this.checkboxes.selected, tag, value);
      },
      submit: function () {
        this.showErrors = true;
        if (this.preventUpload || this.submitting)
          return;
        var self = this;
        this.submitting = true;
        var data = new FormData();
        var post_file = this.$refs['post_file'];
        if (post_file && post_file.files && post_file.files.length) {
          data.append('upload[file]', this.$refs['post_file'].files[0]);
        } else {
          data.append('upload[direct_url]', this.uploadURL);
        }
        data.append('upload[tag_string]', this.tags);
        data.append('upload[rating]', this.rating);
        data.append('upload[source]', this.sources.join('\n'));
        // data.append('upload[description]', this.description);
        data.append('upload[parent_id]', this.parentID);
        jQuery.ajax('/uploads.json', {
          contentType: false,
          processData: false,
          method: 'POST',
          type: 'POST',
          data: data,
          success: function (data) {
            self.submitting = false;
            notice('Post uploaded successfully.');
            location.assign(data.location);
          },
          error: function (data) {
            self.submitting = false;
            try {
              var data2 = JSON.parse(data.responseText);
              if (data2 && data2.location) {
                error('Error: Post already exists. <a href="' + data2.location + '">View it.</a>');
              } else {
                error('Error: ' + data2.reason);
              }
            } catch (e) {
              error('Error: Unknown error! ' + data);
            }
          }
        });
      },
      pushTag: function (tag, add) {
        this.preview.show = false;
        var isCheck = typeof this.checkboxes.all[tag] !== "undefined";
        // In advanced mode we need to push these into the tags area because there are no checkboxes or other
        // tag fields so we can't see them otherwise.
        if (isCheck && this.normalMode) {
          this.setCheck(tag, add);
          return;
        }
        var tags = this.tagEntries.other ? this.tagEntries.other.trim().split(' ') : [];
        var tagIdx = tags.indexOf(tag);
        if (add) {
          if (tagIdx === -1)
            tags.push(tag);
        } else {
          if (tagIdx === -1)
            return;
          tags.splice(tagIdx, 1);
        }
        this.tagEntries.other = tags.join(' ') + ' ';
      },
      previewFinalTags: function () {
        if (this.preview.loading)
          return;
        if (this.preview.show) {
          this.preview.show = false;
          return;
        }
        this.preview.loading = true;
        this.preview.show = true;
        this.preview.tags = [];
        var self = this;
        var data = {tags: this.tags};
        jQuery.ajax("/tags/preview.json", {
          method: 'POST',
          type: 'POST',
          data: data,
          success: function (result) {
            self.preview.loading = false;
            self.preview.tags = result;
          },
          error: function (result) {
            self.preview.loading = false;
            self.preview.tags = [];
            self.preview.show = false;
            error('Error loading tag preview ' + result);
          }
        })
      },
      findRelated: function (type) {
        const self = this;
        const convertResponse = function (respData) {
          var sortedRelated = [];
          for (var key in respData) {
            if (!respData.hasOwnProperty(key)) {
              continue;
            }
            sortedRelated.push({title: 'Related: ' + key, tags: respData[key].sort(tagSorter)});
          }
          return sortedRelated;
        };
        const getSelectedTags = function () {
          const field = self.$refs['otherTags'];
          if (!field.hasOwnProperty('selectionStart'))
            return null;
          const length = field.selectionEnd - field.selectionStart;
          if (length)
            return field.value.substr(field.selectionStart, length);
          return null;
        };
        this.loadingRelated = true;
        this.relatedTags = [];
        const selectedTags = getSelectedTags();
        const params = selectedTags ? {query: selectedTags} : {query: this.tags};

        if (type)
          params['category'] = type;
        $.getJSON("/related_tag/bulk.json", params, function(data) {
          self.relatedTags = convertResponse(data);
        }).always(function() {
          self.loadingRelated = false;
        });
      }
    },
    computed: {
      tags: function () {
        var self = this;
        var checked = Object.keys(this.checkboxes.selected).filter(function (x) {
          return self.checkboxes.selected[x] === true;
        });
        return checked.concat([this.tagEntries.other, this.tagEntries.sex, this.tagEntries.bodyType,
          this.tagEntries.theme, this.tagEntries.character]).join(' ').replace(',', ' ').trim().replace(/ +/g, ' ');
      },
      tagsArray: function () {
        return this.tags.toLowerCase().split(' ');
      },
      previewDimensions: function () {
        if (this.previewWidth && this.previewHeight)
          return this.previewHeight + '×' + this.previewWidth;
        return '';
      },
      directURLProblem: function () {
        return directURLCheck(this.uploadURL);
      },
      badDirectURL: function () {
        return !!this.directURLProblem;
      },
      sourceWarning: function () {
        var validSourceCount = this.sources.filter(function (i) {
          return i.length > 0;
        }).length;
        return !this.noSource && (validSourceCount === 0);
      },
      tagCount: function () {
        return this.tags.split(' ').filter(function (x) {
          return x;
        }).length;
      },
      notEnoughTags: function () {
        return this.tagCount < 4;
      },
      invalidRating: function () {
        return !this.rating;
      },
      preventUpload: function () {
        return this.sourceWarning || this.badDirectURL || this.notEnoughTags
          || this.invalidRating;
      }
    }
  });
  var main = new Vue({
    el: '#post-add',
    components: {
      'post-creator': editor
    }
  });
</script>
